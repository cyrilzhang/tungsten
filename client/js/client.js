// Generated by CoffeeScript 1.6.3
var Compiler, Controller, Parser, Prompt, trimSpaces;

trimSpaces = function(str) {
  return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
};

Parser = {
  findProneIndices: function(str, open_brackets, close_brackets, literal_markers) {
    var bracket_level, c, close, i, lit, literal_level, open, prone, _i, _j, _k, _ref, _ref1, _ref2;
    bracket_level = [];
    literal_level = [];
    for (i = _i = 1, _ref = open_brackets.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      bracket_level.push(0);
    }
    for (i = _j = 1, _ref1 = literal_markers.length; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      literal_level.push(0);
    }
    prone = [];
    for (i = _k = 0, _ref2 = str.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      c = str.charAt(i);
      lit = literal_markers.indexOf(c);
      open = open_brackets.indexOf(c);
      close = close_brackets.indexOf(c);
      if (lit !== -1) {
        literal_level[lit] = 1 - literal_level[lit];
      } else if (_.without(literal_level, 0).length === 0) {
        if (open !== -1) {
          bracket_level[open] += 1;
        } else if (close !== -1) {
          bracket_level[close] -= 1;
        } else if (_.without(literal_level, 0).length === 0 && _.without(bracket_level, 0).length === 0) {
          prone.push(i);
        }
      }
    }
    return prone;
  },
  parseAt: function(str) {
    var commas, equals, expr, i, pos, prone, raw_subs, sub, subs, this_sub, this_var, x, _i, _j, _k, _len, _ref, _ref1;
    pos = str.search(" at ");
    if (pos === -1) {
      return null;
    }
    expr = trimSpaces(str.substr(0, pos));
    if (expr === "") {
      return {
        error: "substitution with empty expression"
      };
    }
    raw_subs = str.substr(pos + 4);
    prone = Parser.findProneIndices(raw_subs, "([{", ")]}", "'\"`");
    commas = [-1];
    for (i = _i = 0, _len = prone.length; _i < _len; i = ++_i) {
      x = prone[i];
      if (raw_subs.charAt(x) === ',') {
        commas.push(i);
      }
    }
    commas.push(str.length);
    subs = [];
    for (i = _j = 0, _ref = commas.length - 2; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
      sub = trimSpaces(raw_subs.substr(commas[i] + 1, commas[i + 1] - commas[i] - 1));
      equals = [];
      for (i = _k = 0, _ref1 = sub.length - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        if (raw_subs.charAt(i) === '=' && raw_subs.charAt(i + 1) !== '=' && raw_subs.charAt(i - 1) !== '=') {
          equals.push(i);
        }
      }
      if (equals.length === 0) {
        return {
          error: "substitution with no '=' tokens"
        };
      } else if (equals.length >= 2) {
        return {
          error: "substitution with too many '=' tokens"
        };
      } else {
        this_var = trimSpaces(sub.substr(0, equals[0]));
        this_sub = trimSpaces(sub.substr(equals[0] + 1));
        if (this_var === "") {
          return {
            error: "substitution with no variable"
          };
        }
        if (this_sub === "") {
          return {
            error: "substitution with no expression"
          };
        }
        subs.push({
          "var": this_var,
          sub: Parser.parseExpr(this_sub)
        });
      }
    }
    if (subs.length === 0) {
      return {
        error: "no substitutions"
      };
    }
    return {
      type: "at",
      body: Parser.parseExpr(expr),
      subs: subs
    };
  },
  parseLet: function(str) {
    return null;
  },
  resolveNaturalLiterals: function(str) {
    var chunk, i, in_nat, pos, prone, ret, x, _i, _len;
    prone = Parser.findProneIndices(str, "", "", "'\"");
    prone.push(str.length);
    pos = -1;
    in_nat = 0;
    ret = [];
    for (i = _i = 0, _len = prone.length; _i < _len; i = ++_i) {
      x = prone[i];
      if (x === str.length || str.charAt(x, prone) === '`') {
        chunk = str.substr(pos + 1, x - pos - 1);
        if (in_nat) {
          ret.push(' WolframAlpha[ "', chunk, '", "MathematicaResult" ] ');
        } else {
          ret.push(' ', chunk, ' ');
        }
        pos = x;
        in_nat = 1 - in_nat;
      }
    }
    return ret.join('');
  },
  resolveLineVariables: function(str) {
    var aux, hits, prev, prone, pronestr, raw_hits, x, _i, _len;
    prone = Parser.findProneIndices(str, "", "", "'\"`");
    prone.push(str.length);
    aux = [];
    prev = 0;
    for (_i = 0, _len = prone.length; _i < _len; _i++) {
      x = prone[_i];
      ++prev;
      while (prev < x) {
        aux.push(' ');
        ++prev;
      }
      aux.push(str.charAt(x));
    }
    pronestr = aux.join('');
    raw_hits = _.uniq(pronestr.match(/<([1-9][0-9]*)>/g));
    hits = raw_hits.map(function(x) {
      return parseInt(x.substr(1, x.length - 2) - 1);
    });
    return hits;
  },
  parseExpr: function(str) {
    str = Parser.resolveNaturalLiterals(str);
    return {
      type: "expr",
      expr: str
    };
  },
  parse: function(str) {
    var p_at, p_let;
    p_let = Parser.parseLet(str);
    p_at = Parser.parseAt(str);
    if (p_let !== null) {
      return null;
    }
    if (p_at !== null) {
      return p_at;
    }
    return Parser.parseExpr(str);
  }
};

Compiler = {
  compileExpr: function(tree) {
    return tree.expr;
  },
  compile: function(tree) {
    var context, i, query, ret, sub, _i, _len, _ref;
    context = [];
    if (tree.type === "at") {
      ret = [" ( ", Compiler.compileExpr(tree.body), " /. ", " { "];
      _ref = tree.subs;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        sub = _ref[i];
        if (i !== 0) {
          ret.push(" , ");
        }
        ret.push(sub["var"], " -> ", Compiler.compileExpr(sub.sub));
      }
      ret.push(" } ) ");
      query = ret.join('');
    } else if (tree.type === "expr") {
      query = Compiler.compileExpr(tree);
    }
    return {
      query: query
    };
  }
};

Controller = {
  ip: '127.0.0.1',
  port: '8000',
  getUrl: function() {
    return "http://" + Controller.ip + ":" + Controller.port + "/";
  },
  get: function(msg, callback, ajaxerr_callback, syntaxerr_callback) {
    var compiled, data, tree;
    tree = Parser.parse(" " + msg + " ");
    if (tree.error != null) {
      return syntaxerr_callback(tree.error);
    } else {
      compiled = Compiler.compile(tree);
      data = [];
      data.push("OutputData = " + compiled.query);
      return $.post(Controller.getUrl(), {
        data: data.join('')
      }, callback).error(ajaxerr_callback);
    }
  }
};

Prompt = {
  count: 1,
  active: null,
  history: [],
  results: [],
  history_pos: 0,
  toggles: [true, false, false],
  dots: null,
  make: function(prefix, content) {
    var block, c, p;
    p = $('<div class="prompt-p"/>').text(prefix);
    c = $('<input type="text" class="prompt-c"/>').val(content);
    return block = $('<div class="prompt-b"/>').append(p, c);
  },
  hist: function(prefix, content) {
    var block;
    block = Prompt.make(prefix, content);
    block.find('input').attr('readonly', 'readonly');
    return $('#container').append(block);
  },
  submit: function() {
    var cmd, out;
    if (!Prompt.active.find(".prompt-c").is(":focus")) {
      Prompt.active.find(".prompt-c").focus();
      return;
    }
    cmd = Prompt.active.find(".prompt-c").val();
    if (cmd === "") {
      return;
    }
    Prompt.active.hide();
    Prompt.ndots = 0;
    Prompt.dots.show();
    Prompt.history.push(cmd);
    Prompt.history_pos = Prompt.history.length;
    Prompt.hist(Prompt.count + ">", cmd);
    return out = Controller.get(cmd, Prompt.success, Prompt.ajaxError, Prompt.syntaxError);
  },
  success: function(out) {
    var block, line1, line2, segments;
    segments = out.split('%%%');
    segments[0] = trimSpaces(segments[0]);
    segments[1] = trimSpaces(segments[1]);
    block = $('<div class="output texrender"/>').text("$" + segments[0] + "$");
    line1 = $('<div class="output texcode"/>').text(segments[0]);
    line2 = $('<div class="output mathcode"/>').text(segments[1]);
    if (!Prompt.toggles[0]) {
      block.hide();
    }
    if (!Prompt.toggles[1]) {
      line1.hide();
    }
    if (!Prompt.toggles[2]) {
      line2.hide();
    }
    Prompt.results.push(segments[1]);
    $('#container').append(block, line1, line2);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, block[0]]);
    return Prompt.next(true);
  },
  next: function(success) {
    if (success) {
      Prompt.count += 1;
    }
    Prompt.active.show();
    Prompt.dots.hide();
    Prompt.active.find(".prompt-p").text(Prompt.count + ">");
    Prompt.active.find(".prompt-c").val("").focus();
    return $('html, body').scrollTop($(document).height());
  },
  ajaxError: function(out) {
    var errline;
    errline = $('<div class="output error"/>').text("Connection error");
    $('#container').append(errline);
    return Prompt.next(false);
  },
  syntaxError: function(out) {
    var errline;
    errline = $('<div class="output error"/>').text("Syntax error: " + out);
    $('#container').append(errline);
    return Prompt.next(false);
  },
  up: function() {
    if (Prompt.history_pos > 0) {
      --Prompt.history_pos;
      Prompt.active.find(".prompt-c").val(Prompt.history[Prompt.history_pos]);
    }
    return false;
  },
  down: function() {
    if (Prompt.history_pos < Prompt.history.length) {
      ++Prompt.history_pos;
      if (Prompt.history_pos === Prompt.history.length) {
        Prompt.active.find(".prompt-c").val("");
      } else {
        Prompt.active.find(".prompt-c").val(Prompt.history[Prompt.history_pos]);
      }
    }
    return false;
  },
  ndots: 0,
  tick: function() {
    Prompt.ndots = (Prompt.ndots + 1) % 5;
    return Prompt.dots.text(Array(Prompt.ndots + 2).join("."));
  }
};

$(function() {
  Prompt.active = $("#prompt").append(Prompt.make("", ""));
  Prompt.active.find(".prompt-p").text(Prompt.count + ">");
  Prompt.dots = $("#dots");
  setInterval(Prompt.tick, 100);
  $("#wa").click(function() {
    return location.reload();
  });
  $("#toggl1").click(function(e) {
    $("#toggl1").toggleClass("down");
    Prompt.toggles[0] = !Prompt.toggles[0];
    if (Prompt.toggles[0]) {
      $(".texrender").show();
    } else {
      $(".texrender").hide();
    }
    return window.scrollTo(0, document.body.scrollHeight);
  });
  $("#toggl2").click(function(e) {
    $("#toggl2").toggleClass("down");
    Prompt.toggles[1] = !Prompt.toggles[1];
    if (Prompt.toggles[1]) {
      $(".texcode").show();
    } else {
      $(".texcode").hide();
    }
    return window.scrollTo(0, document.body.scrollHeight);
  });
  $("#toggl3").click(function(e) {
    $("#toggl3").toggleClass("down");
    Prompt.toggles[2] = !Prompt.toggles[2];
    if (Prompt.toggles[2]) {
      $(".mathcode").show();
    } else {
      $(".mathcode").hide();
    }
    return window.scrollTo(0, document.body.scrollHeight);
  });
  $(window).keydown(function(e) {
    switch (e.which) {
      case 13:
        return Prompt.submit();
      case 38:
        return Prompt.up();
      case 40:
        return Prompt.down();
      case 17:
      case 91:
        return false;
    }
  }).click(function(e) {
    if (e.target.id === "parent-target") {
      return Prompt.active.find(".prompt-c").focus();
    }
  });
  return Prompt.active.find(".prompt-c").focus();
});
